#!/bin/bash

set -e

# SafeClaude - Secure Claude Code sandbox with GitHub-enforced branch protection
# Version 2.0.0

SCRIPT_VERSION="2.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Source library files
if [ -f "$SCRIPT_DIR/lib/registry.sh" ]; then
    source "$SCRIPT_DIR/lib/registry.sh"
fi
if [ -f "$SCRIPT_DIR/lib/keys.sh" ]; then
    source "$SCRIPT_DIR/lib/keys.sh"
fi
if [ -f "$SCRIPT_DIR/lib/docker.sh" ]; then
    source "$SCRIPT_DIR/lib/docker.sh"
fi
if [ -f "$SCRIPT_DIR/lib/container.sh" ]; then
    source "$SCRIPT_DIR/lib/container.sh"
fi

# Print usage
usage() {
    cat <<EOF
${GREEN}SafeClaude${NC} v${SCRIPT_VERSION} - Secure Claude Code sandbox

${BLUE}SETUP COMMANDS${NC}
  setup <name> <repo-url>       Set up a new project
  list                          List all configured projects
  remove <name>                 Remove a project

${BLUE}RUN COMMANDS${NC}
  run <name> [OPTIONS]          Run Claude Code for a project
  resume <name>                 Resume a transferred conversation

  Options for 'run':
    --no-network                    Disable network access (enabled by default)
    --persist                       Persist Claude config between sessions
    --use-host-prompt=true/false    Copy CLAUDE.md (default: true)
    --use-host-agents=true/false    Copy agents/ (default: true)
    --use-host-commands=true/false  Copy commands/ (default: true)
    --mount <host-path>:<container-path>[:<ro|rw>]
                                    Mount local file or directory (can be repeated)
                                    Default mode is read-only (ro)

${BLUE}BACKGROUND COMMANDS${NC}
  start <name> <agent-name>     Start Claude in background
  attach <agent-name>           Attach to a running agent
  logs <agent-name> [-f]        View agent logs (-f to follow)
  ps                            List all running containers
  stop <agent-name>             Stop and remove an agent

${BLUE}CONFIGURATION COMMANDS${NC}
  config set <key> <value>      Set a config value
  config get [key]              Get config value(s)
  config list                   List all config
  config set-api-key <key>      Store Anthropic API key (optional)
  config get-api-key            Show stored API key (masked)
  config remove-api-key         Remove API key from config

${BLUE}RECOVERY COMMANDS${NC}
  recovery list <project>       List recovery bundles for a project
  recovery apply <project> <id> Apply a recovery bundle
  recovery clear <project> [id] Clear recovery bundles

${BLUE}UTILITY COMMANDS${NC}
  --help, help                  Show this help message
  --version                     Show version information

${BLUE}EXAMPLES${NC}
  # Setup a new project
  safeclaude setup myrepo git@github.com:user/myrepo.git

  # Run the project
  safeclaude run myrepo

  # Run with network and persistence
  safeclaude run myrepo --persist

  # Disable copying slash commands (e.g., if they depend on MCP tools)
  safeclaude run myrepo --use-host-commands=false

  # Or set it as a default in config
  safeclaude config set use_host_commands false

  # Run without copying host config
  safeclaude run myrepo --no-host-config

  # Mount a local file for reference
  safeclaude run myrepo --mount /path/to/design.md:/workspace/design.md

  # Mount multiple files/directories
  safeclaude run myrepo \\
    --mount ~/docs/spec.md:/workspace/spec.md:ro \\
    --mount ~/data:/workspace/data:rw

  # Start in background
  safeclaude start myrepo agent-1

  # Attach to it
  safeclaude attach agent-1

  # List recovery bundles (after a crash)
  safeclaude recovery list myrepo

  # Apply a recovery bundle
  safeclaude recovery apply myrepo abc123def456

${BLUE}SECURITY${NC}
  - Per-project deploy keys (isolated credentials)
  - GitHub branch protection enforcement (server-side)
  - Container isolation (ephemeral workspaces)
  - Network enabled by default (required for git operations)

EOF
    exit 0
}

# Check if Docker is installed
check_docker() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}Error: Docker is not installed${NC}"
        echo "Please install Docker: https://docs.docker.com/get-docker/"
        exit 1
    fi
}

# Check if Docker image exists
check_image() {
    if ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
        echo -e "${RED}Error: SafeClaude image '$IMAGE_NAME' not found${NC}"
        echo "Please run ./install.sh first to build the image"
        exit 1
    fi
}

# Check if jq is installed
check_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is not installed${NC}"
        echo ""
        echo "Install it with:"
        echo "  macOS:   brew install jq"
        echo "  Linux:   apt-get install jq / yum install jq"
        exit 1
    fi
}

# Setup a new project
cmd_setup() {
    local name="$1"
    local repo_url="$2"

    if [ -z "$name" ] || [ -z "$repo_url" ]; then
        echo -e "${RED}Error: Both project name and repository URL are required${NC}"
        echo "Usage: safeclaude setup <name> <repo-url>"
        exit 1
    fi

    # Validate project name (alphanumeric, hyphens, underscores only)
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo -e "${RED}Error: Project name must contain only letters, numbers, hyphens, and underscores${NC}"
        echo "Invalid name: $name"
        exit 1
    fi

    # Validate project name length
    if [ ${#name} -gt 64 ]; then
        echo -e "${RED}Error: Project name too long (max 64 characters)${NC}"
        exit 1
    fi

    echo -e "${GREEN}SafeClaude Project Setup${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # Check if gh CLI is installed
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: GitHub CLI (gh) is not installed${NC}"
        echo ""
        echo "Install it with:"
        echo "  macOS:   brew install gh"
        echo "  Linux:   See https://github.com/cli/cli#installation"
        echo ""
        echo "Then authenticate: gh auth login"
        exit 1
    fi

    # Check if authenticated
    if ! gh auth status &> /dev/null; then
        echo -e "${RED}Error: Not authenticated with GitHub CLI${NC}"
        echo ""
        echo "Please run: gh auth login"
        exit 1
    fi

    # Extract owner/repo from URL
    local owner_repo
    if [[ "$repo_url" =~ github.com[:/]([^/]+/[^/]+)(\.git)?$ ]]; then
        owner_repo="${BASH_REMATCH[1]}"
        owner_repo="${owner_repo%.git}"

        # Validate owner/repo format (alphanumeric, hyphens, underscores, dots for repo)
        if [[ ! "$owner_repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
            echo -e "${RED}Error: Invalid repository format in URL${NC}"
            echo "Repository format should be: owner/repo"
            echo "Got: $owner_repo"
            exit 1
        fi
    else
        echo -e "${RED}Error: Invalid GitHub repository URL${NC}"
        echo "Expected format: git@github.com:owner/repo.git or https://github.com/owner/repo.git"
        exit 1
    fi

    echo "Project:    $name"
    echo "Repository: $owner_repo"
    echo ""

    # Check if project already exists
    local reuse_key=false
    if project_exists "$name"; then
        echo -e "${YELLOW}Warning: Project '$name' already exists${NC}"

        # Check if existing deploy key can be reused
        if key_exists "$name" && check_key_settings_match "$owner_repo" "$name"; then
            echo "Existing deploy key found with matching settings"
            read -p "Reuse existing deploy key? [Y/n] " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                echo "Will generate new deploy key and delete old one from GitHub"
                if ! delete_github_key "$owner_repo" "$name"; then
                    echo "Warning: Could not delete old deploy key from GitHub"
                    echo "Continuing with new key generation..."
                fi
                delete_key "$name"
            else
                echo -e "${GREEN}✓ Reusing existing deploy key${NC}"
                reuse_key=true
            fi
        else
            read -p "Overwrite? [y/N] " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Aborted"
                exit 0
            fi
            # Delete old key from GitHub before creating new one
            echo "Deleting old deploy key from GitHub..."
            if ! delete_github_key "$owner_repo" "$name"; then
                echo "Warning: Could not delete old deploy key from GitHub"
                echo "Continuing with new key generation..."
            fi
            delete_key "$name"
        fi
        echo ""
    fi

    # Generate or reuse deploy key
    if [ "$reuse_key" = true ]; then
        local key_path=$(get_key_path "$name")
        echo "Using existing deploy key at $key_path"
        echo ""
    else
        echo "Generating deploy key..."
        local key_path=$(generate_deploy_key "$name")
        echo -e "${GREEN}✓ Deploy key generated at $key_path${NC}"
        echo ""

        # Add deploy key to GitHub
        echo "Adding deploy key to GitHub..."
        if gh repo deploy-key add "$key_path.pub" \
            --allow-write \
            --title "safeclaude-$name" \
            --repo "$owner_repo" 2>&1; then
            echo -e "${GREEN}✓ Deploy key added to GitHub${NC}"
        else
            echo -e "${YELLOW}⚠ Deploy key may already exist (this is fine)${NC}"
        fi
        echo ""
    fi

    # Check current branch protection settings
    echo "Checking branch protection on 'main'..."
    local enforce_admins="true"
    local current_enforce_admins

    # Try to get current enforce_admins setting
    if current_enforce_admins=$(gh api "repos/$owner_repo/branches/main/protection" --jq '.enforce_admins.enabled' 2>/dev/null); then
        echo "Current branch protection found: enforce_admins=$current_enforce_admins"

        if [ "$current_enforce_admins" = "false" ]; then
            echo ""
            echo -e "${YELLOW}⚠️  Security Notice: Admin Bypass Detected${NC}"
            echo ""
            echo "Your branch protection currently allows admins (and deploy keys with"
            echo "write access) to bypass the pull request requirement."
            echo ""
            echo "Options:"
            echo "  1. Enable enforce_admins=true  (More Secure)"
            echo "     - Deploy keys CANNOT push directly to main"
            echo "     - Your account CANNOT push directly to main"
            echo "     - All changes must go through pull requests"
            echo ""
            echo "  2. Keep enforce_admins=false  (Less Secure, More Convenient)"
            echo "     - Deploy keys CAN bypass and push directly to main"
            echo "     - Your account CAN bypass and push directly to main"
            echo "     - Provides convenience but reduces security"
            echo ""
            read -p "Enable enforce_admins for maximum security? [Y/n] " -n 1 -r
            echo ""

            if [[ $REPLY =~ ^[Nn]$ ]]; then
                enforce_admins="false"
                echo -e "${YELLOW}⚠ Keeping enforce_admins=false (deploy keys can bypass protection)${NC}"
            else
                enforce_admins="true"
                echo -e "${GREEN}✓ Will enable enforce_admins=true (maximum security)${NC}"
            fi
            echo ""
        else
            enforce_admins="true"
            echo -e "${GREEN}✓ enforce_admins is already enabled${NC}"
            echo ""
        fi
    else
        # Branch protection doesn't exist yet
        echo "No branch protection found (will create with default settings)"
        echo ""
        echo -e "${BLUE}Branch Protection Configuration${NC}"
        echo ""
        echo "SafeClaude will enable branch protection requiring pull requests."
        echo ""
        echo "Choose security level for enforce_admins:"
        echo "  1. true  - Maximum security (recommended for untrusted AI)"
        echo "     Deploy keys CANNOT push directly to main"
        echo ""
        echo "  2. false - Convenience mode (less secure)"
        echo "     Deploy keys CAN bypass and push directly to main"
        echo ""
        read -p "Enable strict enforcement (enforce_admins=true)? [Y/n] " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Nn]$ ]]; then
            enforce_admins="false"
            echo -e "${YELLOW}⚠ Using enforce_admins=false (less secure)${NC}"
        else
            enforce_admins="true"
            echo -e "${GREEN}✓ Using enforce_admins=true (maximum security)${NC}"
        fi
        echo ""
    fi

    # Apply branch protection with chosen setting
    echo "Applying branch protection settings..."
    if gh api "repos/$owner_repo/branches/main/protection" \
        --method PUT \
        --field "required_pull_request_reviews[required_approving_review_count]=0" \
        --field "enforce_admins=$enforce_admins" \
        --field "required_status_checks=null" \
        --field "restrictions=null" &> /dev/null; then
        echo -e "${GREEN}✓ Branch protection configured (enforce_admins=$enforce_admins)${NC}"
    else
        echo -e "${YELLOW}⚠ Could not update branch protection${NC}"
    fi
    echo ""

    # Add to registry
    add_project "$name" "$repo_url" "$owner_repo" "$key_path" "main"

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${GREEN}Setup complete!${NC}"
    echo ""
    echo "You can now run:"
    echo "  safeclaude run $name"
    echo ""
}

# List all projects
cmd_list() {
    echo -e "${GREEN}Configured Projects${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    local projects=$(list_projects)

    if [ "$projects" = "{}" ]; then
        echo "No projects configured yet"
        echo ""
        echo "Add a project with:"
        echo "  safeclaude setup <name> <repo-url>"
        return
    fi

    # Parse and display projects
    echo "$projects" | jq -r 'to_entries[] | "\(.key)\t\(.value.owner_repo)\t\(.value.last_used)"' | \
        while IFS=$'\t' read -r name owner_repo last_used; do
            printf "  ${BLUE}%-20s${NC} %s\n" "$name" "$owner_repo"
            printf "    Last used: %s\n\n" "$last_used"
        done
}

# Remove a project
cmd_remove() {
    local name="$1"

    if [ -z "$name" ]; then
        echo -e "${RED}Error: Project name required${NC}"
        echo "Usage: safeclaude remove <name>"
        exit 1
    fi

    if ! project_exists "$name"; then
        echo -e "${RED}Error: Project '$name' not found${NC}"
        exit 1
    fi

    # Get owner/repo before removing from registry
    local owner_repo=$(get_project_owner_repo "$name")

    echo -e "${YELLOW}Remove project '$name'?${NC}"
    echo "This will:"
    echo "  - Remove from registry"
    echo "  - Delete local deploy key"
    echo "  - Delete deploy key from GitHub"
    echo ""
    read -p "Continue? [y/N] " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted"
        exit 0
    fi

    # Delete deploy key from GitHub
    echo "Deleting deploy key from GitHub..."
    if delete_github_key "$owner_repo" "$name"; then
        echo -e "${GREEN}✓ Deploy key deleted from GitHub${NC}"
    else
        echo -e "${YELLOW}⚠ Could not delete deploy key from GitHub${NC}"
        echo "Please delete it manually at: https://github.com/$owner_repo/settings/keys"
    fi

    # Delete local deploy key
    delete_key "$name"

    # Remove from registry
    remove_project "$name"

    echo -e "${GREEN}Project '$name' removed${NC}"
}

# Run a project
cmd_run() {
    local name="$1"
    shift

    if [ -z "$name" ]; then
        echo -e "${RED}Error: Project name required${NC}"
        echo "Usage: safeclaude run <name> [OPTIONS]"
        exit 1
    fi

    if ! project_exists "$name"; then
        echo -e "${RED}Error: Project '$name' not found${NC}"
        echo ""
        echo "Available projects:"
        cmd_list
        exit 1
    fi

    # Try to load API key from config if not in environment
    # This is optional - Claude Code CLI can use subscription auth
    if [ -z "$ANTHROPIC_API_KEY" ]; then
        local stored_key=$(get_api_key)
        if [ -n "$stored_key" ]; then
            export ANTHROPIC_API_KEY="$stored_key"
            echo -e "${BLUE}Using API key from config${NC}"
        fi
        # If no API key, Claude Code will use subscription authentication
    fi

    # Check if OAuth token is expired or expiring soon
    check_token_expiry
    local expiry_status=$?
    if [ $expiry_status -eq 1 ]; then
        # Token is expired - block execution
        exit 1
    fi
    # Status 2 (warning) or 0 (valid) - continue

    # Get project details
    local repo_url=$(get_project_url "$name")
    local key_path=$(get_project_key_path "$name")

    if [ ! -f "$key_path" ]; then
        echo -e "${RED}Error: Deploy key not found at $key_path${NC}"
        echo "Try running: safeclaude setup $name <repo-url>"
        exit 1
    fi

    # Update last used
    update_last_used "$name"

    # Read config defaults and prepend them to arguments
    # This allows command-line flags to override config settings
    local config_args=()

    # Read host config settings from config and convert to flags
    local use_prompt=$(get_config_value 'use_host_prompt' 'true')
    local use_agents=$(get_config_value 'use_host_agents' 'true')
    local use_commands=$(get_config_value 'use_host_commands' 'true')

    config_args+=("--use-host-prompt=$use_prompt")
    config_args+=("--use-host-agents=$use_agents")
    config_args+=("--use-host-commands=$use_commands")

    # Get sandbox instructions file path
    local instructions_file=$(get_config_value 'sandbox_instructions_file' "$SAFECLAUDE_DIR/sandbox_instructions.md")

    # Warn if instructions file is outside home directory
    if [ -n "$instructions_file" ] && [ -f "$instructions_file" ]; then
        if [[ ! "$instructions_file" =~ ^$HOME/ ]] && [[ ! "$instructions_file" =~ ^$SAFECLAUDE_DIR/ ]]; then
            echo -e "${YELLOW}Warning: sandbox_instructions_file is outside your home directory${NC}"
            echo "  File: $instructions_file"
            echo "  This file will be readable by Claude in the container."
            echo ""
        fi
    fi

    echo -e "${GREEN}SafeClaude${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Project:    $name"
    echo "Repository: $repo_url"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "Launching sandbox container..."
    echo ""

    # Build and execute docker command (config args + user args)
    build_docker_command "$name" "$repo_url" "$key_path" "$instructions_file" "${config_args[@]}" "$@"
    execute_docker_command

    echo ""
    echo -e "${GREEN}Sandbox session ended${NC}"
    echo "Container has been automatically removed"
}

# Resume a transferred conversation
cmd_resume() {
    local name="$1"

    if [ -z "$name" ]; then
        echo -e "${RED}Error: Project name required${NC}"
        echo "Usage: safeclaude resume <name>"
        exit 1
    fi

    # Validate project name (alphanumeric, hyphens, underscores only)
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo -e "${RED}Error: Project name must contain only letters, numbers, hyphens, and underscores${NC}"
        echo "Invalid name: $name"
        exit 1
    fi

    # Validate project name length
    if [ ${#name} -gt 64 ]; then
        echo -e "${RED}Error: Project name too long (max 64 characters)${NC}"
        exit 1
    fi

    if ! project_exists "$name"; then
        echo -e "${RED}Error: Project '$name' not found${NC}"
        echo ""
        echo "Available projects:"
        cmd_list
        exit 1
    fi

    # Find transfer files for this project
    local transfer_files=()
    local metadata_files=()
    local transfer_dir="$SAFECLAUDE_DIR/transfer"

    while IFS= read -r -d '' meta_file; do
        # Verify file is actually in transfer directory (security check)
        local file_dir=$(dirname "$meta_file")
        if [ "$file_dir" != "$transfer_dir" ]; then
            echo -e "${YELLOW}Warning: Skipping file outside transfer directory${NC}" >&2
            continue
        fi
        metadata_files+=("$meta_file")
    done < <(find "$transfer_dir" -maxdepth 1 -type f -name "${name}-*.json" -print0 2>/dev/null | sort -z -r)

    if [ ${#metadata_files[@]} -eq 0 ]; then
        echo -e "${RED}No transferred conversations found for '$name'${NC}"
        echo ""
        echo "Transfer a conversation first using: /safeclaude $name"
        echo "Then exit Claude and run this command again."
        exit 1
    fi

    # If multiple transfers exist, show menu
    local selected_meta=""
    if [ ${#metadata_files[@]} -gt 1 ]; then
        echo -e "${GREEN}Multiple conversations available for '$name'${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""

        local idx=1
        for meta_file in "${metadata_files[@]}"; do
            local summary=$(jq -r '.summary' "$meta_file" 2>/dev/null || echo "No summary")
            local timestamp=$(jq -r '.timestamp' "$meta_file" 2>/dev/null || echo "0")
            local created=$(jq -r '.created' "$meta_file" 2>/dev/null || echo "Unknown")
            local last_msg=$(jq -r '.last_messages[0] // "No preview"' "$meta_file" 2>/dev/null)

            # Calculate time ago
            local now=$(date +%s)
            local diff=$((now - timestamp))
            local time_ago=""
            if [ $diff -lt 60 ]; then
                time_ago="${diff}s ago"
            elif [ $diff -lt 3600 ]; then
                time_ago="$((diff / 60))m ago"
            elif [ $diff -lt 86400 ]; then
                time_ago="$((diff / 3600))h ago"
            else
                time_ago="$((diff / 86400))d ago"
            fi

            echo -e "  ${BLUE}$idx.${NC} [$time_ago] $summary"
            echo "     Last: ${last_msg:0:70}..."
            echo ""

            idx=$((idx + 1))
        done

        echo -n "Select conversation (1-${#metadata_files[@]}, or 'q' to cancel): "
        read -r selection

        if [ "$selection" = "q" ] || [ "$selection" = "Q" ]; then
            echo "Cancelled"
            exit 0
        fi

        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#metadata_files[@]} ]; then
            echo -e "${RED}Invalid selection${NC}"
            exit 1
        fi

        selected_meta="${metadata_files[$((selection - 1))]}"
    else
        selected_meta="${metadata_files[0]}"
        local summary=$(jq -r '.summary' "$selected_meta" 2>/dev/null || echo "Conversation")
        echo -e "${GREEN}Resuming: $summary${NC}"
        echo ""
    fi

    # Extract metadata
    local format_version=$(jq -r '.format_version // "1.0"' "$selected_meta" 2>/dev/null)
    local conversation_id=$(jq -r '.conversation_id' "$selected_meta" 2>/dev/null)
    local timestamp=$(jq -r '.timestamp' "$selected_meta" 2>/dev/null)

    # Validate format version
    if [ "$format_version" != "1.0" ]; then
        echo -e "${YELLOW}Warning: Metadata format version $format_version may not be fully compatible${NC}"
        echo "This script supports format version 1.0"
        echo ""
        read -p "Attempt to resume anyway? [y/N] " -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled"
            exit 0
        fi
        echo ""
    fi

    # Validate metadata
    if [ -z "$conversation_id" ] || [ "$conversation_id" = "null" ]; then
        echo -e "${RED}Error: Invalid metadata (missing conversation_id)${NC}"
        exit 1
    fi

    # Validate conversation_id is UUID format (case-insensitive per RFC 4122)
    if [[ ! "$conversation_id" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
        echo -e "${RED}Error: Invalid conversation ID format${NC}"
        exit 1
    fi

    # Validate timestamp is numeric
    if [ -z "$timestamp" ] || [ "$timestamp" = "null" ] || ! [[ "$timestamp" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Invalid timestamp format${NC}"
        exit 1
    fi

    local transfer_jsonl="$SAFECLAUDE_DIR/transfer/${name}-${timestamp}.jsonl"

    # Verify conversation file exists and is readable
    if [ ! -f "$transfer_jsonl" ]; then
        echo -e "${RED}Error: Conversation file not found: $transfer_jsonl${NC}"
        exit 1
    fi

    if [ ! -r "$transfer_jsonl" ]; then
        echo -e "${RED}Error: Cannot read conversation file: $transfer_jsonl${NC}"
        exit 1
    fi

    # Quick validation of JSONL format
    if ! head -1 "$transfer_jsonl" | jq empty 2>/dev/null; then
        echo -e "${RED}Error: Conversation file is not valid JSONL${NC}"
        exit 1
    fi

    # Determine the project directory path that Claude expects
    # Use shared constant from lib/docker.sh to ensure consistency
    local project_dir="$CONTAINER_WORKDIR"
    local project_dir_name=$(echo "$project_dir" | sed 's|/|-|g')
    local container_history_path="/home/node/.claude/projects/${project_dir_name}/${conversation_id}.jsonl"

    echo "Mounting conversation history..."
    echo ""

    # Run with the conversation mounted and --persist to save it
    cmd_run "$name" \
        --mount "${transfer_jsonl}:${container_history_path}:rw" \
        --persist

    local exit_code=$?

    # Only clean up if container exited successfully AND volume was created
    if [ $exit_code -eq 0 ]; then
        # Verify the persistence volume exists (conversation should be saved there)
        local volume_name="safeclaude-${name}-config"
        if docker volume inspect "$volume_name" &>/dev/null; then
            echo ""
            echo "Cleaning up transfer files..."
            if rm -f "$selected_meta" "$transfer_jsonl"; then
                echo -e "${GREEN}✓ Transfer files removed${NC}"
                echo -e "${GREEN}✓ Conversation persisted to volume: $volume_name${NC}"
            else
                echo -e "${YELLOW}⚠ Warning: Could not remove transfer files${NC}"
                echo "  Files remain at:"
                echo "    $selected_meta"
                echo "    $transfer_jsonl"
            fi
        else
            echo ""
            echo -e "${YELLOW}⚠ Warning: Persistence volume not found${NC}"
            echo "  Transfer files preserved for safety:"
            echo "    $selected_meta"
            echo "    $transfer_jsonl"
            echo "  You can retry with: safeclaude resume $name"
        fi
    else
        echo ""
        echo -e "${YELLOW}⚠ Container exited with code $exit_code${NC}"
        echo "  Transfer files preserved for retry:"
        echo "    $selected_meta"
        echo "    $transfer_jsonl"
        echo "  You can retry with: safeclaude resume $name"
    fi
}

# Start a project in background
cmd_start() {
    local name="$1"
    local agent_name="$2"

    if [ -z "$name" ] || [ -z "$agent_name" ]; then
        echo -e "${RED}Error: Project name and agent name are required${NC}"
        echo "Usage: safeclaude start <name> <agent-name>"
        exit 1
    fi

    # Validate agent name (alphanumeric, hyphens, underscores only)
    if [[ ! "$agent_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo -e "${RED}Error: Agent name must contain only letters, numbers, hyphens, and underscores${NC}"
        echo "Invalid name: $agent_name"
        exit 1
    fi

    # Validate agent name length
    if [ ${#agent_name} -gt 64 ]; then
        echo -e "${RED}Error: Agent name too long (max 64 characters)${NC}"
        exit 1
    fi

    if ! project_exists "$name"; then
        echo -e "${RED}Error: Project '$name' not found${NC}"
        exit 1
    fi

    # Try to load API key from config if not in environment
    # This is optional - Claude Code CLI can use subscription auth
    if [ -z "$ANTHROPIC_API_KEY" ]; then
        local stored_key=$(get_api_key)
        if [ -n "$stored_key" ]; then
            export ANTHROPIC_API_KEY="$stored_key"
            echo -e "${BLUE}Using API key from config${NC}"
        fi
        # If no API key, Claude Code will use subscription authentication
    fi

    # Check if OAuth token is expired or expiring soon
    check_token_expiry
    local expiry_status=$?
    if [ $expiry_status -eq 1 ]; then
        # Token is expired - block execution
        exit 1
    fi
    # Status 2 (warning) or 0 (valid) - continue

    # Get project details
    local repo_url=$(get_project_url "$name")
    local key_path=$(get_project_key_path "$name")

    if [ ! -f "$key_path" ]; then
        echo -e "${RED}Error: Deploy key not found at $key_path${NC}"
        exit 1
    fi

    # Check if agent already exists
    if container_exists "$name-$agent_name"; then
        echo -e "${RED}Error: Agent '$agent_name' already exists for project '$name'${NC}"
        echo "Use a different name or stop the existing agent:"
        echo "  safeclaude stop $name-$agent_name"
        exit 1
    fi

    # Update last used
    update_last_used "$name"

    # Get sandbox instructions file path
    local instructions_file=$(get_config_value 'sandbox_instructions_file' "$SAFECLAUDE_DIR/sandbox_instructions.md")

    echo -e "${GREEN}Starting agent '$agent_name' for project '$name'...${NC}"
    echo ""

    # Build and execute docker command in detached mode
    build_docker_command "$name" "$repo_url" "$key_path" "$instructions_file" --detach --name "$agent_name"
    execute_docker_command

    # Give container time to fail if it's going to
    sleep 2

    # Check if container is still running
    if ! container_running "$name-$agent_name"; then
        echo -e "${RED}Error: Container failed to start${NC}"
        echo ""
        echo "View error logs with:"
        echo "  safeclaude logs $name-$agent_name"
        exit 1
    fi

    echo -e "${GREEN}Agent started successfully${NC}"
    echo ""
    echo "Attach to it with:"
    echo "  safeclaude attach $name-$agent_name"
    echo ""
    echo "View logs with:"
    echo "  safeclaude logs $name-$agent_name"
}

# Attach to a running container
cmd_attach() {
    local container_name="$1"

    if [ -z "$container_name" ]; then
        echo -e "${RED}Error: Container name required${NC}"
        echo "Usage: safeclaude attach <container-name>"
        exit 1
    fi

    attach_container "$container_name"
}

# Show container logs
cmd_logs() {
    local container_name="$1"
    local follow_flag="$2"

    if [ -z "$container_name" ]; then
        echo -e "${RED}Error: Container name required${NC}"
        echo "Usage: safeclaude logs <container-name> [-f]"
        exit 1
    fi

    show_logs "$container_name" "$follow_flag"
}

# List running containers
cmd_ps() {
    echo -e "${GREEN}Running SafeClaude Containers${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    list_containers
}

# Stop a container
cmd_stop() {
    local container_name="$1"

    if [ -z "$container_name" ]; then
        echo -e "${RED}Error: Container name required${NC}"
        echo "Usage: safeclaude stop <container-name>"
        exit 1
    fi

    stop_container "$container_name"
}

# Configuration management
cmd_config() {
    local subcommand="$1"
    shift || true

    case "$subcommand" in
        set-api-key)
            local api_key="$1"

            if [ -z "$api_key" ]; then
                echo -e "${RED}Error: API key required${NC}"
                echo "Usage: safeclaude config set-api-key <key>"
                exit 1
            fi

            # Validate key format (basic check)
            if [[ ! "$api_key" =~ ^sk-ant- ]]; then
                echo -e "${YELLOW}Warning: API key doesn't start with 'sk-ant-'${NC}"
                read -p "Continue anyway? [y/N] " -n 1 -r
                echo ""
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    exit 0
                fi
            fi

            # Show security warning
            echo -e "${YELLOW}⚠️  WARNING: Security Notice${NC}"
            echo ""
            echo "Your API key will be stored in plaintext at:"
            echo "  $SAFECLAUDE_DIR/config.json"
            echo ""
            echo "This is convenient but less secure than environment variables."
            echo "Any process running as your user can read this file."
            echo ""
            echo "Note: API keys are optional if you have a Claude Code subscription."
            echo "Claude Code will use your subscription auth automatically."
            echo ""
            echo "Alternative (more secure):"
            echo "  export ANTHROPIC_API_KEY='$api_key'"
            echo "  # Add to ~/.zshrc or ~/.bashrc for persistence"
            echo ""
            read -p "Store in config anyway? [y/N] " -n 1 -r
            echo ""

            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Cancelled"
                exit 0
            fi

            if set_api_key "$api_key"; then
                echo -e "${GREEN}✓ API key saved to config${NC}"
                echo ""
                echo "The API key will be used automatically if ANTHROPIC_API_KEY"
                echo "environment variable is not set."
            else
                echo -e "${RED}Error: Failed to save API key${NC}"
                exit 1
            fi
            ;;

        get-api-key)
            local stored_key=$(get_api_key)

            if [ -z "$stored_key" ]; then
                echo "No API key stored in config"
                echo ""
                echo "Note: API keys are optional if you have a Claude Code subscription."
                echo ""
                echo "To set an API key:"
                echo "  safeclaude config set-api-key <key>"
                echo ""
                echo "Or use environment variable:"
                echo "  export ANTHROPIC_API_KEY='sk-ant-...'"
                exit 0
            fi

            # Mask the key for security (show first 12 chars + ...)
            local masked_key="${stored_key:0:12}...${stored_key: -4}"
            echo "Stored API key: $masked_key"
            echo "Location: $SAFECLAUDE_DIR/config.json"
            ;;

        remove-api-key)
            local stored_key=$(get_api_key)

            if [ -z "$stored_key" ]; then
                echo "No API key stored in config"
                exit 0
            fi

            read -p "Remove API key from config? [y/N] " -n 1 -r
            echo ""

            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Cancelled"
                exit 0
            fi

            if remove_api_key; then
                echo -e "${GREEN}✓ API key removed from config${NC}"
            else
                echo -e "${RED}Error: Failed to remove API key${NC}"
                exit 1
            fi
            ;;

        set)
            local key="$1"
            local value="$2"

            if [ -z "$key" ] || [ -z "$value" ]; then
                echo -e "${RED}Error: Both key and value required${NC}"
                echo "Usage: safeclaude config set <key> <value>"
                echo ""
                echo "Available keys:"
                echo "  use_host_prompt      Copy CLAUDE.md (true/false)"
                echo "  use_host_agents      Copy agents/ (true/false)"
                echo "  use_host_commands    Copy commands/ (true/false)"
                echo "  default_network      Enable network by default (true/false)"
                echo "  default_persist      Enable persistence by default (true/false)"
                exit 1
            fi

            if set_config_value "$key" "$value"; then
                echo -e "${GREEN}✓ Config updated: $key = $value${NC}"
            else
                echo -e "${RED}Error: Failed to update config${NC}"
                exit 1
            fi
            ;;

        get)
            local key="$1"

            if [ -z "$key" ]; then
                # Show all config
                echo -e "${GREEN}SafeClaude Configuration${NC}"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                cat "$SAFECLAUDE_DIR/config.json" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
                echo ""
                echo "Location: $SAFECLAUDE_DIR/config.json"
            else
                local value=$(get_config_value "$key")
                echo "$key: $value"
            fi
            ;;

        list)
            echo -e "${GREEN}SafeClaude Configuration${NC}"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            cat "$SAFECLAUDE_DIR/config.json" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
            echo ""
            echo "Location: $SAFECLAUDE_DIR/config.json"
            ;;

        *)
            echo -e "${RED}Error: Unknown config subcommand '$subcommand'${NC}"
            echo ""
            echo "Available subcommands:"
            echo "  safeclaude config set <key> <value>      Set a config value"
            echo "  safeclaude config get [key]              Get config value(s)"
            echo "  safeclaude config list                   List all config"
            echo "  safeclaude config set-api-key <key>      Store API key"
            echo "  safeclaude config get-api-key            Show API key"
            echo "  safeclaude config remove-api-key         Remove API key"
            exit 1
            ;;
    esac
}

# Recovery management
cmd_recovery() {
    local subcommand="$1"
    shift || true

    case "$subcommand" in
        list)
            local project="$1"

            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: safeclaude recovery list <project>"
                exit 1
            fi

            if ! project_exists "$project"; then
                echo -e "${RED}Error: Project '$project' not found${NC}"
                exit 1
            fi

            local recovery_dir="$SAFECLAUDE_DIR/recovery/$project"

            if [ ! -d "$recovery_dir" ]; then
                echo "No recovery bundles found for '$project'"
                exit 0
            fi

            # Find all JSON metadata files
            local metadata_files=()
            while IFS= read -r -d '' meta_file; do
                metadata_files+=("$meta_file")
            done < <(find "$recovery_dir" -maxdepth 1 -type f -name '*.json' -print0 2>/dev/null | sort -z -r)

            if [ ${#metadata_files[@]} -eq 0 ]; then
                echo "No recovery bundles found for '$project'"
                exit 0
            fi

            echo -e "${GREEN}Recovery Bundles for '$project'${NC}"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""

            for meta_file in "${metadata_files[@]}"; do
                local container_id=$(jq -r '.container_id // "unknown"' "$meta_file" 2>/dev/null)
                local session_start=$(jq -r '.session_start // "unknown"' "$meta_file" 2>/dev/null)
                local last_update=$(jq -r '.last_update // "unknown"' "$meta_file" 2>/dev/null)
                local commits=$(jq -r '.commits // 0' "$meta_file" 2>/dev/null)
                local branches=$(jq -r '.branches // [] | join(", ")' "$meta_file" 2>/dev/null)
                local last_commit=$(jq -r '.last_commit // "No commits"' "$meta_file" 2>/dev/null)

                echo -e "  ${BLUE}Container:${NC} $container_id"
                echo -e "  ${BLUE}Session:${NC}   $session_start"
                echo -e "  ${BLUE}Updated:${NC}   $last_update"
                echo -e "  ${BLUE}Commits:${NC}   $commits"
                echo -e "  ${BLUE}Branches:${NC}  $branches"
                echo -e "  ${BLUE}Last:${NC}      ${last_commit:0:70}"
                echo ""
            done

            echo "To apply a bundle, run:"
            echo "  safeclaude recovery apply <project> <container-id>"
            ;;

        apply)
            local project="$1"
            local container_id="$2"

            if [ -z "$project" ] || [ -z "$container_id" ]; then
                echo -e "${RED}Error: Project name and container ID required${NC}"
                echo "Usage: safeclaude recovery apply <project> <container-id>"
                exit 1
            fi

            if ! project_exists "$project"; then
                echo -e "${RED}Error: Project '$project' not found${NC}"
                exit 1
            fi

            local recovery_dir="$SAFECLAUDE_DIR/recovery/$project"
            local bundle_file="$recovery_dir/${container_id}.bundle"
            local meta_file="$recovery_dir/${container_id}.json"

            if [ ! -f "$bundle_file" ]; then
                echo -e "${RED}Error: Bundle not found: $bundle_file${NC}"
                echo ""
                echo "Available bundles:"
                cmd_recovery list "$project"
                exit 1
            fi

            # Verify we're in a git repository
            if ! git rev-parse --git-dir > /dev/null 2>&1; then
                echo -e "${RED}Error: Not in a git repository${NC}"
                echo "Please cd to your project repository and try again"
                exit 1
            fi

            # Verify remote URL matches project
            local expected_url=$(get_project_url "$project")
            local current_remote=$(git config --get remote.origin.url 2>/dev/null || echo "")

            if [ "$current_remote" != "$expected_url" ]; then
                echo -e "${RED}Error: Repository mismatch${NC}"
                echo "Current repository: $current_remote"
                echo "Expected: $expected_url"
                echo ""
                echo "Please cd to the correct repository"
                exit 1
            fi

            # Show bundle info
            if [ -f "$meta_file" ]; then
                echo -e "${GREEN}Applying Recovery Bundle${NC}"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                local session_start=$(jq -r '.session_start // "unknown"' "$meta_file" 2>/dev/null)
                local commits=$(jq -r '.commits // 0' "$meta_file" 2>/dev/null)
                local branches=$(jq -r '.branches // [] | join(", ")' "$meta_file" 2>/dev/null)
                local last_commit=$(jq -r '.last_commit // ""' "$meta_file" 2>/dev/null)

                echo "Session:  $session_start"
                echo "Commits:  $commits"
                echo "Branches: $branches"
                echo "Last:     $last_commit"
                echo ""
            fi

            # Check for uncommitted changes
            if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                echo -e "${YELLOW}Warning: You have uncommitted changes${NC}"
                echo ""
                read -p "Continue anyway? [y/N] " -n 1 -r
                echo ""
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Cancelled"
                    exit 0
                fi
                echo ""
            fi

            # Fetch from bundle
            echo "Fetching commits from bundle..."
            if ! git fetch "$bundle_file" 'refs/*:refs/recovery/*' 2>&1; then
                echo -e "${RED}Error: Failed to fetch from bundle${NC}"
                exit 1
            fi

            echo -e "${GREEN}✓ Commits fetched successfully${NC}"
            echo ""
            echo "Branches are now available under refs/recovery/"
            echo ""
            echo "To see what was recovered:"
            echo "  git log recovery/<branch-name>"
            echo ""
            echo "To merge a recovered branch:"
            echo "  git merge recovery/<branch-name>"
            echo ""
            echo "To checkout a recovered branch:"
            echo "  git checkout -b <new-branch> recovery/<branch-name>"
            ;;

        clear)
            local project="$1"
            local container_id="$2"

            if [ -z "$project" ]; then
                echo -e "${RED}Error: Project name required${NC}"
                echo "Usage: safeclaude recovery clear <project> [container-id]"
                echo ""
                echo "Examples:"
                echo "  safeclaude recovery clear myproject                 # Clear all bundles"
                echo "  safeclaude recovery clear myproject abc123def456    # Clear specific bundle"
                exit 1
            fi

            if ! project_exists "$project"; then
                echo -e "${RED}Error: Project '$project' not found${NC}"
                exit 1
            fi

            local recovery_dir="$SAFECLAUDE_DIR/recovery/$project"

            if [ ! -d "$recovery_dir" ]; then
                echo "No recovery bundles found for '$project'"
                exit 0
            fi

            if [ -n "$container_id" ]; then
                # Clear specific bundle
                local bundle_file="$recovery_dir/${container_id}.bundle"
                local meta_file="$recovery_dir/${container_id}.json"

                if [ ! -f "$bundle_file" ] && [ ! -f "$meta_file" ]; then
                    echo -e "${RED}Error: Bundle not found for container $container_id${NC}"
                    exit 1
                fi

                echo -e "${YELLOW}Remove recovery bundle for container '$container_id'?${NC}"
                read -p "Continue? [y/N] " -n 1 -r
                echo ""

                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Cancelled"
                    exit 0
                fi

                rm -f "$bundle_file" "$meta_file"
                echo -e "${GREEN}✓ Bundle removed${NC}"
            else
                # Clear all bundles
                local bundle_count=$(find "$recovery_dir" -maxdepth 1 -type f -name '*.bundle' 2>/dev/null | wc -l)

                if [ "$bundle_count" -eq 0 ]; then
                    echo "No recovery bundles found for '$project'"
                    exit 0
                fi

                echo -e "${YELLOW}Remove all $bundle_count recovery bundles for '$project'?${NC}"
                read -p "Continue? [y/N] " -n 1 -r
                echo ""

                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Cancelled"
                    exit 0
                fi

                rm -f "$recovery_dir"/*.bundle "$recovery_dir"/*.json
                echo -e "${GREEN}✓ All bundles removed${NC}"
            fi
            ;;

        *)
            echo -e "${RED}Error: Unknown recovery subcommand '$subcommand'${NC}"
            echo ""
            echo "Available subcommands:"
            echo "  safeclaude recovery list <project>                   List recovery bundles"
            echo "  safeclaude recovery apply <project> <container-id>   Apply a recovery bundle"
            echo "  safeclaude recovery clear <project> [container-id]   Clear recovery bundles"
            exit 1
            ;;
    esac
}

# Main command dispatcher
main() {
    # Check dependencies
    check_docker
    check_image
    check_jq

    # Initialize SafeClaude directory
    init_safeclaude_dir

    # Parse command
    local command="$1"
    shift || true

    case "$command" in
        setup)
            cmd_setup "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        run)
            cmd_run "$@"
            ;;
        resume)
            cmd_resume "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        attach)
            cmd_attach "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        ps)
            cmd_ps
            ;;
        stop)
            cmd_stop "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        recovery)
            cmd_recovery "$@"
            ;;
        --help|help|-h)
            usage
            ;;
        --version|-v)
            echo "SafeClaude v${SCRIPT_VERSION}"
            ;;
        "")
            usage
            ;;
        *)
            echo -e "${RED}Error: Unknown command '$command'${NC}"
            echo ""
            usage
            ;;
    esac
}

main "$@"
